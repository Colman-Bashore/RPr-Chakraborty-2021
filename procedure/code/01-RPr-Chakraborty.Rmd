---
title: "Reproduction of Chakraborty 2021: An intracategorical analysis of COVID-19 and people with disabilities"
author: "Joseph Holler, Junyi Zhou, Peter Kedron, Drew An-Pham, Derrick Burt"
date: "`r Sys.Date()`"
output: pdf_document
editor_options: 
  markdown: 
    wrap: sentence
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../../docs/report") })
---

Version 1.4 \| First Created Jul 7, 2021

# Abstract

Chakraborty (2021) investigates the relationships between COVID-19 rates and demographic characteristics of people with disabilities by county in the lower 48 states.
The study aims to examine public concern that persons with disabilities (PwDs) face disproportionate challenges due to COVID-19.
To investigate this, Chakraborty examines the statistical relationship between confirmed county-level COVID-19 case rates and county-level socio-demographic and disability variables.
Specifically, Chakraborty tests county-level bivariate correlations between COVID-19 incidence against the percentage of disability and socio-demographic category, with a separate hypothesis and model for each subcategory within disability, race, ethnicity, age, and biological sex.
To control for differences between states and geographic clusters of COVID-19 outbreaks, Chakraborty uses five generalized estimating equation (GEE) models to predict the relationship and significance between COVID-19 incidence and disability subgroups within each socio-demographic category while considering inter-county spatial clusters.
Chakraborty (2021) finds significant positive relationships between COVID-19 rates and socially vulnerable demographic categories of race, ethnicity, poverty, age, and biological sex.

This reproduction study is motivated by expanding the potential impact of Chakraborty's study for policy, research, and teaching purposes.
Measuring the relationship between COVID-19 incidence and socio-demographic and disability characteristics can provide important information for public health policy-making and resource allocation.
A fully reproducible study will increase the accessibility, transparency, and potential impact of Chakraborty's (2021) study by publishing a compendium complete with metadata, data, and code.
This will allow other researchers to review, extend, and modify the study and will allow students of geography and spatial epidemiology to learn from the study design and methods.

In this reproduction, we will attempt to identically reproduce all of the results from the original study.
This will include the map of county level distribution of COVID-19 incidence rates (Fig. 1), the summary statistics for disability and sociodemographic variables and bivariate correlations with county-level COVID-19 incidence rate (Table 1), and the GEE models for predicting COVID-19 county-level incidence rate (Table 2).
A successful reproduction should be able to generate identical results as published by Chakraborty (2021).

The replication study data and code will be made available in a GitHub repository to the greatest extent that licensing and file sizes permit.
The repository will be made public at [github.com/HEGSRR/RPr-Chakraborty2021]().

Chakraborty, J. 2021. Social inequities in the distribution of COVID-19: An intra-categorical analysis of people with disabilities in the U.S.
*Disability and Health Journal* 14:1-5. [DOI:[10.1016/j.dhjo.2020.101007](DOI:%5B10.1016/j.dhjo.2020.101007){.uri}]()

## Keywords

COVID-19; Disability; Intersectionality; Race/ethnicity; Poverty; Reproducibility

# Study Design

The reproduction study will attempt to implement the original study as closely as possible to reproduce the map of county level distribution of COVID-19 incidence rate, the summary statistics and bivariate correlation for disability characteristics and COVID-19 incidence, and the generalized estimating equations.
Our two confirmatory hypotheses are that we will be able to exactly reproduce Chakraborty's results as presented in table 1 and table 2 of Chakraborty (2021).
Stated as null hypotheses:

> H1: There is a less than perfect match between Chakraborty's bivariate correlation coefficient for each disability/sociodemographic variable and COVID-19 incidence rate and our bivariate correlation coefficient for each disability/sociodemographic variable and COVID-19 incidence rate.

> H2: There is a less than perfect match between Chakraborty's beta coefficient for the GEE of each disability/sociodemographic variable and our beta coefficient for the GEE of each disability/sociodemographic variable.

There are multiple models being tested within each of the two hypotheses.
That is, H1 and H2 both encompass five models, including one for each dimension of socio-demographics: race, ethnicity, poverty status, age, and biological sex.

# Original study design

The original study is **observational**, with the **exploratory** objective of determining "whether COVID-19 incidence is significantly greater in counties containing higher percentages of socio-demographically disadvantaged [people with disabilities], based on their race, ethnicity, poverty status, age, and biological sex" (Chakraborty 2021).
This exploratory objective is broken down into five implicit hypotheses that each of the demographic characteristics of people with disabilities is associated with higher COVID-19 incidence rates.

The **spatial extent** of the study are the 49 contiguous states in the U.S.
The **spatial scale** of the analysis is at the county level.
Both COVID-19 incidence rates and demographic variables are all measured at the county level.
The **temporal extent** of the COVID-19 data ranges from 1/22/2020 (when John Hopkins began collecting the data) to 8/1/2020 (when the data was retrieved for the original study).
The data on disability and sociodemographic characteristics come from the U.S.
Census American Community Survey (ACS) five-year estimates for 2018 (2014-2018).

There is no **randomization** in the original study.

![](../../docs/report/workflow.jpg "Workflow diagram")

# Computational environment

The study was originally conducted using SaTScan software (unspecified version) to implement the Kulldorff spatial scan statistic.
Other software are not specified in the publication; however data files and communication with the author show that spatial analysis and mapping was conducted in ArcGIS and generalized estimating equation (GEE) models were calculated in SPSS.

This reproduction study uses R, including the SpatialEpi package for the Kulldorff spatial scan statistics and the geepack package for GEE models.

```{r setup, message = FALSE, include = FALSE}
# list of required packages
packages <- c(
  "tidycensus", "tidyverse", "downloader", "sf", "classInt", "readr",
  "here", "s2", "pastecs", "tmap", "SpatialEpi", "svDialogs",
  "geepack", "knitr", "foreign"
)

# load and install required packages
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE, quietly = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

# save the R processing environment
writeLines(
  capture.output(sessionInfo()),
  here("procedure", "environment", paste0("r-environment-", Sys.Date(), ".txt"))
)

# set up default knitr parameters
knitr::opts_chunk$set(
  echo = FALSE,
  fig.width = 8,
  fig.path = here("results", "figures")
)
```

# Data

## American Community Survey

American Community Survey (ACS) data for sociodemographic subcategories of people with disabilities can be accessed by using the `tidycensus` package to query the Census API. This requires an API key which can be acquired at [api.census.gov/data/key_signup.html](https://api.census.gov/data/key_signup.html)

```{r API-Load-ACS, message = FALSE, data_acquisition}
# get API Key
# we could store this in the raw/private or scratch folder and load if the
# researcher has already entered it once
census_api_key(
  dlgInput(
    "Enter a Census API Key",
    Sys.getenv("CENSUS_API_KEY")
  )$res,
  overwrite = TRUE
)

# Query disability demographic data with geographic boundaries
acs <- get_acs(
  geography = "county",
  table = "S1810",
  year = 2018,
  output = "wide",
  cache_table = TRUE,
  geometry = TRUE,
  keep_geo_vars = TRUE
)

# Query poverty and disability data
acs_pov <- get_acs(
  geography = "county",
  table = "C18130",
  year = 2018,
  output = "wide",
  cache_table = TRUE
)

# Query state geographic data
state <- get_acs(
  geography = "state",
  year = 2018,
  variables = c("B01001_001"),
  geometry = TRUE,
  keep_geo_vars = TRUE
)
```

The original study extent is the lower 48 states and Washington D.C. Therefore, Alaska, Hawai'i and Puerto Rico are removed from the data (workflow step 1).
Data on people with disabilities in poverty is derived from a different census table (C18130) than data on people with disabilities and age, race, ethnicity, age, and biological sex (S1810).
Therefore, join the poverty data to the other data using the GEOID (workflow step 3).

```{r filter-join-acs, eval = FALSE}
# Remove Alaska, Hawaii & Puerto Rico
acs <- filter(acs, !STATEFP %in% c("02", "15", "72"))
state <- filter(state, !STATEFP %in% c("02", "15", "72"))

# Join poverty data to disability data
acs <- left_join(acs, acs_pov, by = "GEOID")
rm(acs_pov)
```

Save the raw ACS data to `data/raw/public/acs.gpkg`

```{r save-ACS, message = F, eval = FALSE}
# Save downloaded acs data to acs.gpkg
write_sf(
  acs,
  here("data", "raw", "public", "acs.gpkg"),
  layer = "acs"
)
write_sf(
  state,
  here("data", "raw", "public", "acs.gpkg"),
  layer = "state"
)
```

Load the raw ACS data.
Optionally, begin processing here.

```{r load-ACS, message = FALSE}
acs <- read_sf(here("data", "raw", "public", "acs.gpkg"), layer = "acs")
state <- read_sf(here("data", "raw", "public", "acs.gpkg"), layer = "state")
```

Calculate independent socio-demographic variables of people with disabilities as percentages for each sub-category of disability (race, ethnicity, poverty, age, and biological sex) and remove raw census data from the data frame (workflow step 4).
Reproject the data into an Albers equal area conic projection.

```{r Preprocess-ACS, message = FALSE}
# calculate percentages
acs_derived <- mutate(acs,
  dis_pct = S1810_C02_001E / S1810_C01_001E * 100,
  white_pct = S1810_C02_004E / S1810_C01_001E * 100,
  black_pct = S1810_C02_005E / S1810_C01_001E * 100,
  native_pct = S1810_C02_006E / S1810_C01_001E * 100,
  asian_pct = S1810_C02_007E / S1810_C01_001E * 100,
  other_pct =
    (S1810_C02_008E + S1810_C02_009E + S1810_C02_010E) / S1810_C01_001E * 100,
  non_hisp_white_pct = S1810_C02_011E / S1810_C01_001E * 100,
  hisp_pct = S1810_C02_012E / S1810_C01_001E * 100,
  non_hisp_non_white_pct =
    (S1810_C02_001E - S1810_C02_012E - S1810_C02_011E) / S1810_C01_001E * 100,
  bpov_pct = (C18130_004E + C18130_011E + C18130_018E) / C18130_001E * 100,
  apov_pct = (C18130_005E + C18130_012E + C18130_019E) / C18130_001E * 100,
  pct_5_17 = S1810_C02_014E / S1810_C01_001E * 100,
  pct_18_34 = S1810_C02_015E / S1810_C01_001E * 100,
  pct_35_64 = S1810_C02_016E / S1810_C01_001E * 100,
  pct_65_74 = S1810_C02_017E / S1810_C01_001E * 100,
  pct_75 = S1810_C02_018E / S1810_C01_001E * 100,
  male_pct = S1810_C02_002E / S1810_C01_001E * 100,
  female_pct = S1810_C02_003E / S1810_C01_001E * 100
)

# select only relevant geographic identifiers and derived percentages
# and transform to USA Contiguous Albers Equal Area Conic projection
acs_derived <- acs_derived %>%
  select(
    fips = GEOID,
    statefp = STATEFP,
    county = NAME.x,
    county_st = NAME,
    contains("pct")
  ) %>%
  st_transform(5070) %>%
  st_make_valid()

head(acs_derived)
```

## COVID-19 rates

Data on COVID-19 rates from the Johns Hopkins University dashboard have been provided directly with the research compendium because the data is no longer available online in the state in which it was downloaded on August 1, 2020.
The dashboard and cumulative counts of COVID-19 cases and deaths were continually updated, so an exact reproduction required communication with the original author, Jayajit Chakraborty, for assistance with provision of data from August 1, 2020.

```{r load-covid-data}
covid <- read_sf(here("data", "raw", "public", "covidcase080120.gpkg"))
covid <- select(covid,
  fips = FIPS,
  pop = POP_ESTIMA,
  cases = Confirmed,
  x = X, y = Y
)
```

Calculate the COVID incidence rate as the cases per 100,000 people (workflow step 2).
Convert the COVID data to a non-geographic data frame.

```{r covid-rate}
covid_table <- covid %>% 
  mutate(covid_rate = round(covid$cases / covid$pop * 100000, 2)) %>% 
  st_drop_geometry()
head(covid_table)
```

Join dependent COVID data to independent ACS sociodemographic data.

```{r join-covid-to-acs}
# Join COVID incidence rate data to acs data
acs_covid <- acs_derived %>%
  left_join(covid_table, by = "fips")

# move covid_rate column prior to disability percentages
acs_covid <- acs_covid %>%
  select(fips, statefp, county, county_st, covid_rate, everything())

rm(acs, acs_derived, covid)
head(acs_covid)
```

## Missing Data

There is one county with missing disability and poverty data.
This was not mentioned in the original study or our pre-analyis plan.
However, we replace the missing data with zeros, producing results identical to Chakraborty's.

```{r missing data}
# county with missing data
filter(acs_covid, is.na(bpov_pct)) %>% st_drop_geometry()

# replace NA with 0 for missing data
acs_covid[is.na(acs_covid$bpov_pct), ]$bpov_pct <- 0
acs_covid[is.na(acs_covid$apov_pct), ]$apov_pct <- 0
```

## Map COVID-19 Incidence

Map the county level distribution of COVID-19 incidence rates, comparing to Figure 1 of the original study.

```{r map-covid-rates, message = FALSE}
tm1 <- tm_shape(acs_covid) +
  tm_polygons("covid_rate",
    title = "COVID-19 Cases per 100,000 people\n(22 January 2020 to 1 August 2020)",
    style = "quantile",
    border.alpha = .2,
    lwd = 0.2,
    palette = "YlOrBr",
  ) +
  tm_shape(state) +
  tm_borders("grey", lwd = .5) +
  tm_layout(
    legend.position = c("left", "bottom"),
    legend.title.size = 0.8,
    legend.text.size = 0.5
  )

tm1

tmap_save(tm1, here("results", "figures", "covid_rates.png"))
```

## Map Disability

**Planned deviation for reanalysis**: We also map the spatial distribution of the percent of people with any disability.

```{r map-disability-rates, message = FALSE}
tm2 <- tm_shape(acs_covid) +
  tm_polygons("dis_pct",
    title = "Percent of People with Disability\n(ACS 2014-2018)",
    style = "quantile",
    border.alpha = .2,
    lwd = 0.2,
    palette = "YlOrBr"
  ) +
  tm_shape(state) +
  tm_borders("grey", lwd = .5) +
  tm_layout(
    legend.position = c("left", "bottom"),
    legend.title.size = 0.8,
    legend.text.size = 0.5
  )

tm2

tmap_save(tm2, here("results", "figures", "disability_rates.png"))
```

## Descriptive Statistics

Calculate descriptive statistics for dependent covid rate and independent socio-demographic characteristics, reproducing the min, max, mean, and SD columns of original study table 1.

**Planned deviation for reanalysis**: We also calculate the Shapiro Wilk test for normality.

```{r descriptive-statistics}
acs_covid_stats <- acs_covid %>%
  st_drop_geometry() %>%
  select(covid_rate, contains("pct")) %>%
  stat.desc(norm = TRUE) %>%
  round(2) %>%
  t() %>%
  as.data.frame() %>%
  select(min, max, mean, SD = std.dev, ShapiroWilk = normtest.W, p = normtest.p)

acs_covid_stats %>% kable()
```

Compare reproduced descriptive statistics to original descriptive statistics.
Difference is calculated as 'reproduction study - original study'.
Identical results will result in zero.

```{r compare-descriptive-stats}
# load original table 1 results
table1 <- read.csv(here("data", "raw", "public", "chakraborty", "table1.csv"))
# subtract original results from reproduced results
(select(acs_covid_stats, min, max, mean, SD) -
  select(table1, min, max, mean, SD)) %>%
  kable()
rm(acs_covid_stats)
```

The descriptive statistics are identical, except that the original study seems to have rounded the COVID-19 statistics to zero decimal places.

# Analytical Methods

## Bivariate Parametric Correlation Analysis

Calculate Pearson's R Correlation Coefficient of each independent variable and the COVID-19 incidence rate, reproducing the Pearson's R column of original study Table 1.

```{r pearsons-correlation}
df <- sum(!is.na(acs_covid$dis_pct)) - 2

pearsons_r <- acs_covid %>%
  select(where(is.numeric)) %>%
  st_drop_geometry() %>%
  cor(method = "pearson", use = "everything") %>%
  as.data.frame() %>%
  select(r = covid_rate) %>%
  mutate(
    t = abs(r) / sqrt((1 - r^2) / (df)),
    p = pt(t, df, lower.tail = FALSE)
  ) %>%
  round(3) %>%
  rownames_to_column("variable") %>%
  filter(variable != "covid_rate")

pearsons_r %>% kable()
```

Compare the reproduced Pearson's *r* correlation coefficients to the original study's Pearson's *r* correlation coefficients.
Stars indicates the significance level with two stars for `p < 0.01` and one star for `p < 0.05`.
is calculated as `reproduction study - original study` Direction difference is calculated as `(reproduction > 0) - (original > 0)`, giving 0 if both coefficients have the same direction, 1 if the reproduction is positive and the original is negative, and -1 if the reproduction is negative but the original is positive.

```{r compare-pearsons-correlation}
# calculate number of significance stars at p<0.01 and P<0.05 levels.
pearsons_r <- mutate(pearsons_r, rp_stars = as.numeric(as.character(cut(p,
  breaks = c(-0.1, 0.01, 0.05, 1),
  labels = c(2, 1, 0)
))))

# join reproduction coefficients to original study coefficients
correlations <- table1 %>%
  filter(variable != "covid_rate") %>%
  select(variable, or_r = r, or_stars = stars) %>%
  left_join(select(pearsons_r, variable, rp_r = r, rp_stars), by = "variable")

# find difference between coefficient and stars
correlations <- correlations %>%
  bind_cols(rename_with(
    correlations[, 4:5] - correlations[, 2:3],
    ~ paste0(.x, "_diff")
  ))

# find coefficients with different directions
correlations <- correlations %>% mutate(rp_dir_diff = (rp_r > 0) - (or_r > 0))

correlations %>% kable()
```

All but one Pearson's correlation coefficient was significant to the same level, and the exception was age 18 to 34.
Counter-intuitively, the correlation coefficient was slightly lower but the *p* value was also found to be lower, suggesting a difference in the *p* value calculation or a clerical error.
However, the correlation coefficient was nearly identical and 
All of the coefficients had the same direction.
The reproduced Pearson's *r* coefficients were inexact but very similar to the original study, falling within a range of +/-0.006.

**Unplanned Deviation for Reproduction**: We should expect identical results for this correlation test, so we loaded the original author's data from `Aug1GEEdata.csv` to re-test the statistic, calculated as `unplanned_r` below.

```{r original-data-pearson-correlation}
# load author-provided original data
original_gee <- read.csv(here("data", "raw", "public", "chakraborty", "Aug1GEEdata.csv"))

# calculate correlation coefficients using original data
original_gee %>%
  select(Incidence, PerDisable, starts_with("PD")) %>%
  cor(method = "pearson", use = "everything") %>%
  as.data.frame() %>%
  rownames_to_column("or_variable") %>%
  filter(or_variable != "Incidence") %>%
  select(or_variable, unplanned_r = Incidence) %>%
  bind_cols(correlations[, 1:2]) %>%
  mutate(unplanned_r = round(unplanned_r, 3), diff = unplanned_r - or_r) %>%
  select(variable, unplanned_r, or_r, diff) %>%
  kable()
```

The author's original data produced coefficients identical to the original publication!
Considering the bitwise reproduction of descriptive statistics along with the accurate recalculation of correlation statistics from original data, could it be possible that the data values are correct but have been reassigned / transposed to different counties?

*Unplanned Deviation for Reproduction*: We re-calculate the COVID-19 incidence rate with the original author's data and filter for unequal results.

```{r compare-incidence-rate}
# recalculate Incidence Rate
original_gee <- original_gee %>%
  mutate(recalc_Incidence = round(Cases / Total_POP * 100000, 2))

# compare recalculation to author-provided original data and print any counties
# with inconsistent results
original_gee %>%
  filter(recalc_Incidence != Incidence) %>%
  select(COUNTY_FIPS, ST_Name, Countyname, Total_POP, Cases, Incidence, recalc_Incidence) %>%
  mutate(Incidence__diff = recalc_Incidence - Incidence) %>% 
  kable()
```

We found that 13 counties had incorrect COVID-19 incidence scores, and the scores seem to be transposed to other counties, such that the overall descriptive statistics were accurate but the correlation coefficients were inaccurate.
This finding implies that subsequent analyses using the calculated COVID-19 Incidence rate will be slightly different and more accurate in this reproduction study than in the original study

## Bivariate Nonparametric Correlation Analysis

**Unplanned Deviation for Reproduction**: The dependent and independent variables in this study do not have normal distributions, as shown in the Shapiro-Wilk test results above.
Therefore, we deviate from the original study to use the Spearman's Rho non-parametric correlation test.

```{r spearmans correlation}
df <- sum(!is.na(acs_covid$dis_pct)) - 2

spearmans_rho <- acs_covid %>%
  select(where(is.numeric)) %>%
  st_drop_geometry() %>%
  cor(method = "spearman", use = "everything") %>%
  as.data.frame() %>%
  select(rho = covid_rate) %>%
  mutate(
    t = abs(rho) / sqrt((1 - rho^2) / (df)),
    p = pt(t, df, lower.tail = FALSE)
  ) %>%
  round(3) %>%
  rownames_to_column("variable") %>%
  filter(variable != "covid_rate")
```

Compare the Spearman's *rho* correlation coefficients to the reproduced Pearson's *r* correlation coefficients.

```{r compare-spearmans-correlation}
# calculate number of significance stars at p<0.01 and P<0.05 levels.
spearmans_rho <- mutate(spearmans_rho, rp_rho_stars = as.numeric(as.character(cut(p,
  breaks = c(-0.1, 0.01, 0.05, 1),
  labels = c(2, 1, 0)
))))

correlations <- correlations[, 1:8] %>%
  left_join(select(spearmans_rho, variable, rp_rho = rho, rp_rho_stars), by = "variable")

corrdiff <- select(correlations, starts_with("rp_rho")) -
  select(correlations, rp_r, rp_stars)

correlations <- correlations %>% bind_cols(rename_with(corrdiff, ~ paste0(.x, "_diff")))
rm(corrdiff)

correlations <- correlations %>% mutate(rp_rho_dir_diff = (rp_rho > 0) - (rp_r > 0))

correlations %>%
  select(variable, rp_r, rp_stars, starts_with("rp_rho")) %>%
  kable()
```

Three variables change significance levels, with Native American and Other races gaining significance and age 18-34 losing significance.
Two correlations change direction, with both Native American race and Female households switching from positive correlations to negative correlations.
Instabilities between the parametric and non-parametic correlations reflect variables with very skewed distributions and/or weak correlations at the county level.
Some difference may also be attributable to the 13 counties with data errors in the COVID-19 Incidence Rate.
In such distributions, the tails and outliers have more weight in parametric tests than in non-parametric tests.
This is illustrated with a scatterplot and linear regression below.

```{r plot-bivariate, fig.width=4, fig.height=4}
plot(acs_covid$native_pct,
  acs_covid$covid_rate,
  xlab = "Percent Native American",
  ylab = "COVID-19 Incidence",
  pch = 16,
  col = rgb(0, 0, 0, 0.1),
  cex.lab = 0.8,
  cex.axis = 0.5,
)
lines(abline(lm(acs_covid$covid_rate ~ acs_covid$native_pct)))

rm(spearmans_rho, pearsons_r, correlations, table1, df)
```

## Kulldorff Spatial Scan Statistic

We use a Kulldorff spatial scan statistic to detect spatial clusters of high COVID-19 incidence (workflow step 6).
The statistic uses a Monte Carlo simulation, and therefore may not produce identical results each time.

The original study uses SaTScan software to implement the Kulldorff spatial scan statistic model.
In SaTScan, the model is specified with many parameters having significant implications for results.
The original manuscript original manuscript only specifies that Poisson model should be used.
We can also intuit that the model is discrete (locations are stationary and non-random), and spatial only (there is no temporal dimension).
The author-provided SaTScan results `SatScan_results.txt` contains additional parameters which appear to adhere to the software default settings.
User decisions about which secondary clusters to include can have significant influence on results.
Major options include criteria of no geographical overlap, optimization using the GINI coefficient, no secondary clusters with their centers in other clusters, or all clusters.
In this case, the default option for "no geographical overlap" of secondary clusters is selected.

SaTScan software can also output two versions of geographic data:

- The `col` cluster polygon shapefile contains a circle for each cluster, where each polygon is a circle defined by the cluster center and radius. The attributes include a variable `REL_RISK` for cluster relative risk
- The `gis` location point shapefile contains one point for each county in a cluster. The attributes include variables `LOC_RR` for local relative risk and `CLU_RR` for cluster relative risk

The author-provided `SatScan_results.txt` indicates a geographic cluster file but no location file, and the author-provided `Aug1GEEdata.csv` data contains a `REL_RISK` column, suggesting that the original study used the `col` polygon cluster shapefile to represent covid risk classes and define GEE clusters.

The SaTScan software implementation of the Kulldorff spatial scan statistic calculates two relative risk scores for locations:

-   local relative risk is the incidence rate of population within a location divided by the incidence rate of the population outside of the location
-   cluster relative risk is the incidence rate of the population within the cluster divided by the incidence rate of the population outside of the cluster

For the purposes of interpreting the spatial scan statistic, a *location* is a *county* while a *cluster* is a *collection of counties* with high incidence rates, defined in the shape of a circle with a center and a radius.

The original study discusses classifying the relative risk of counties, suggesting that the *local* relative risk should be used.
However the `REL_RISK` column in the author-provided data represents cluster relative risk, suggesting that *cluster* relative risk is used.
In this replication, we will reproduce both for comparison to the original study.

The spatial scan statistic is based on case counts and total population, and is therefore unaffected by the inconsistency in calculated COVID Incidence rates.

**Planned deviation for reproduction**: 
We use the SpatialEpi package in R, selecting open source software with R integration over the free but not open SatSCan software. 
The Kulldorff spatial scan statistic model in SpatialEpi also supports a discrete Poisson spatial model, and uses the GINI coefficient to select a set of secondary clusters with no geographical overlap that maximizes the difference between locations inside of clusters and locations outside of clusters.

If you wish to exactly reproduce the same results as our reproduction attempt, please **do not run this section**.
This code block can take more than 10 minutes to run.

```{r SpatialEpi-Kulldorff, eval = FALSE, fig.width=4, fig.height=4}
start_time <- Sys.time()
covid_geo <- covid_table %>%
  select(x, y) %>%
  latlong2grid()
# latlong2grid approximates an equidistant grid measured in kilometers
# need to look more into the methods of this, but it surely is not as good
# as a geodesic calculation. SaTScan uses spherical or ellipsoidal distance
# Latitude is multiplied by 111.133 and Longitude is multiplied by 86.97357

# calculate expected cases with one strata
expected.cases <- expected(covid_table$pop, covid_table$cases, 1)

# Kulldorff spatial scan statistic
covid_kulldorff <- kulldorff(
  geo = covid_geo,
  cases = covid_table$cases,
  population = covid_table$pop,
  expected.cases = expected.cases,
  pop.upper.bound = 0.5,
  n.simulations = 999,
  alpha.level = 0.05,
  plot = TRUE
)

print(
  paste(
    "Run time:",
    round(difftime(Sys.time(), start_time, units = "mins"), 2),
    "minutes"
  ),
  quote = FALSE
)
rm(covid_geo, expected.cases, start_time)
```

Optionally, save the Kulldorff spatial scan results with in a date-stamped `RDS` file.

```{r save-Kulldorff, eval = FALSE}
saveRDS(covid_kulldorff,
  file = here("data", "derived", "public", paste0("covid_kulldorff_", Sys.Date(), ".RDS"))
)
```

Load pre-calculated Kulldorff spatial scan results, or modify this code to load an alternative date-stamped `RDS` file.

```{r load-Kulldorff}
covid_kulldorff <- readRDS(
  here("data", "derived", "public", "covid_kulldorff.RDS")
)
```

Report Kulldorff spatial scan results.

```{r report-Kulldorff}
print("Most likely cluster:", quote = FALSE)
covid_kulldorff$most.likely.cluster
print(
  paste0(
    "Number of Secondary clusters: ",
    length(covid_kulldorff$secondary.clusters)
  ),
  quote = FALSE
)
```

The `SpatialEpi` implementation of Kulldorff spatial scan statistics provides output in the form of hierarchical lists analogous to the text output of SaTScan, but does not output a simple data frame or tabular output analogous to the shapefiles from SaTScan.
Therefore, additional steps are required to append the Kulldorff scan results to the `acs_covid` simple features data frame.
This can be done by assigning unique cluster ID's to each county within a cluster.
Clusters include the county at the center of a cluster and all of the other counties within the cluster radius.
Therefore, we use the FIPS code of the county at the center of each cluster as the unique cluster ID.

```{r assign-cluster-IDs, message = FALSE}
# list of primary cluster locations (counties)
cluster_locations <- covid_kulldorff$most.likely.cluster$location.IDs.included

# create data frame of clusters and
# calculate the clusterID as the first (center) county FIPS code
clusters <- covid_table[cluster_locations, "fips"] %>%
  mutate(clusterID = covid_table[[cluster_locations[1], "fips"]],
         likelihood = covid_kulldorff$most.likely.cluster$log.likelihood.ratio)

# Get a list of secondary clusters
secondary <- covid_kulldorff$secondary.clusters

# similarly add counties in each secondary cluster to the list of clusters
for (i in secondary) {
  cluster_locations <- i$location.IDs.included
  new_clusters <- covid_table[cluster_locations, "fips"] %>%
    mutate(clusterID = covid_table[[cluster_locations[1], "fips"]],
           likelihood = i$log.likelihood.ratio) 
  clusters <- clusters %>% rbind(new_clusters)
}

rm(cluster_locations, secondary, i, new_clusters)
```

Join the Kulldorff spatial scan cluster IDs to the acs_covid simple features dataframe.
Although this is workflow step 9, the order of operations between steps 7 and 8 and step 9 is not important.

```{r join-clusterID-to-acs_covid, message = FALSE}
acs_covid <- acs_covid[, 1:which(colnames(acs_covid) == "y")] %>%
  left_join(clusters, by = "fips") %>%
  mutate(isCluster = case_when(
    clusterID == fips ~ "center",
    !is.na(clusterID) ~ "inside",
    .default = NA
  ))

tmap_mode("view")
tm_basemap("OpenStreetMap.HOT") +
  tm_shape(acs_covid) +
  tm_fill(alpha = 0.7, col = "isCluster", palette = "-Oranges", popup.vars = c("fips", "clusterID"), colorNA = NULL) +
  tm_layout(title = "SpatialEpi Kulldorff Spatial Scan Clusters of COVID-19")
```

**Unplanned deviation for reproduction**:
The `SpatialEpi` implementation of Kulldorff spatial scan statistics does not calculate local relative risk or cluster relative risk.
Therefore, the next step is to calculate local relative risk and cluster relative risk (workflow step 7).

```{r relative-risk}
total_pop <- sum(acs_covid$pop)
total_cases <- sum(acs_covid$cases)

acs_covid <- acs_covid %>%
  # local relative risk by county
  mutate(rr_loc = (cases / pop) / ((total_cases - cases) / (total_pop - pop))) %>%
  # cluster relative risk by groups of counties in each cluster
  group_by(clusterID) %>%
  mutate(
    rr_cluster = ifelse(is.na(clusterID), NA,
      (sum(cases) / sum(pop)) / ((total_cases - sum(cases)) / (total_pop - sum(pop)))
    )
  ) %>%
  ungroup()
```

Classify relative risk on a scale from 1 to 6 (workflow step 8).
Counties falling outside of any cluster are assigned a score of 1.

```{r classify-relative-risk}
# class breaks
breaks <- c(-Inf, 1, 2, 3, 4, 5, Inf)

acs_covid <- acs_covid %>%
  mutate(
    loc_class = ifelse(is.na(clusterID), 1, cut(rr_loc, breaks, labels = FALSE)),
    cluster_class = ifelse(is.na(clusterID), 1, cut(rr_cluster, breaks, labels = FALSE))
  )

acs_covid %>% 
  st_drop_geometry() %>% 
  select(starts_with("rr_"), ends_with("_class"))

rm(breaks)
```

Summarize results of relative risk classification.

```{r risk-classification-results}
# Count frequency of each class of local COVID risk
cat("Classes of LOCAL risk and frequency of counties",
  format(acs_covid %>% st_drop_geometry() %>% count(loc_class)),
  sep = "\n"
)

cat(
  "\n",
  sum(is.na(acs_covid$clusterID) & acs_covid$rr_loc >= 1),
  "counties lie outside of a cluster, but have local relative risk > 1\n",
  sum(is.na(acs_covid$clusterID) & acs_covid$rr_loc < 1),
  "counties lie inside of a cluster, but have a local relative risk < 1"
)

cat("\r\n",
  "Classes of CLUSTER risk and frequency of counties",
  format(acs_covid %>% st_drop_geometry() %>% count(cluster_class)),
  sep = "\n"
)
```

Create cluster IDs as combinations of the relative risk class and the state ID.

```{r make-gee-clusters}
acs_covid <- acs_covid %>% mutate(
  locID = as.integer(statefp) * 10 + loc_class,
  clusID = as.integer(statefp) * 10 + cluster_class
)
```

The original study reported `102` unique clusters having a range of `1` to `245` counties in each cluster.

### Report number of unique clusters and histogram of counties per cluster

```{r report unique clusters}
cluster_summary <- acs_covid %>%
  filter(cases > 0) %>%
  st_drop_geometry() %>%
  count(locID)
cat(
  length(cluster_summary$n),
  "unique clusters based on SpatialEpi LOCAL relative risk\n"
)
summary(cluster_summary$n)
cat("\r\n")
# hist(cluster_summary$n) # improve labels for this graph

cluster_summary <- acs_covid %>%
  filter(cases > 0) %>%
  st_drop_geometry() %>%
  count(clusID)
cat(
  length(cluster_summary$n),
  "unique clusters based on spatialEpi CLUSTER relative risk\n"
)
summary(cluster_summary$n)
rm(cluster_summary)
```

Neither our local relative risk or cluster relative risk classifications reproduced the same configuration of GEE clusters, with each finding more clusters than the original study.

**Unplanned deviation for reproduction**: Upon failing to reproduce an identical number of GEE clusters using SpatialEpi in R, we reproduced the procedure in the free but not open SaTScan software.
The input data files (`case`, `Coordinates.geo`, and `Population.pop`), and output data files (`sat_scan_rpr.txt`, `sat_scan_rpr.col.shp`, and `sat_scan_rpr.gis.shp`) are found in the `data/derived/public/satscan` directory.
The `sat_scan_rpr.txt` file reports the model parameters used in addition to results.

Note that although it is not ideal to revise several steps of analysis with this unplanned deviation, there were no other intermediary results with which to compare the Kulldorff scan statistic results in the original publication.

Load and verify whether our SaTScan reproduction compares to the author-provided data.

```{r load-satscan-col}
# load author-provided data
author_col <- read.dbf(here("data", "raw", "public", "chakraborty", "SatScan_output.dbf")) %>% 
  select(LOC_ID, or_rel_risk = REL_RISK)

# load SaTScan reproduced data
satscan_rpr_col <- read_sf(here("data", "derived", "public", "satscan", "sat_scan_rpr.col.shp"))
satscan_rpr_t <- satscan_rpr_col %>% 
  st_drop_geometry() %>% 
  select(LOC_ID, REL_RISK, GINI_CLUST)

# how many observations?
cat(
  nrow(satscan_rpr_col),
  " reproduced relative risk observations\n",
  nrow(author_col),
  " author-provided relative risk observations\n",
  sep = ""
)

# join and compare how many observations are identical?
cat(
  satscan_rpr_t %>% 
  full_join(author_col, by = "LOC_ID") %>% 
  filter(REL_RISK == or_rel_risk & REL_RISK > 0) %>% 
  nrow(),
  "reproduced relative risk values match the original author's relative risk values"
  )

rm(author_col)
```

Our SaTScan results exactly reproduced the author-provided data.

**Unplanned deviation for reproduction**:
Can we also use our SaTScan results to exactly reproduce the author-reported frequency of original GEE classes and maximum counties per class?

```{r reproduce-gee-clusters}
acs_covid <- acs_covid[, 1:which(colnames(acs_covid) == "clusID")] %>% 
  left_join(satscan_rpr_t, by = join_by(fips == LOC_ID))

# class breaks
breaks <- c(-Inf, 1, 2, 3, 4, 5, Inf)

acs_covid <- acs_covid %>%
  mutate(
    ss_cluster_class = ifelse(is.na(REL_RISK), 1, cut(REL_RISK, breaks, labels = FALSE)),
    ss_clusID = as.integer(statefp) * 10 + ss_cluster_class
  )

cluster_summary <- acs_covid %>%
  filter(cases > 0) %>%
  st_drop_geometry() %>%
  count(ss_clusID)
cat(
  length(cluster_summary$n),
  "unique clusters based on spatialEpi CLUSTER relative risk\n"
)
summary(cluster_summary$n)
```
Using SaTScan Kulldorff clusters, we have exactly reproduced the author-reported frequency of original GEE classes and maximum counties per class.
Note that this version of data only includes the 96 counties defining cluster centers.

This version also includes both clusters with GINI_CLUST = F (i.e. standard hierarchical non-geographic overlap secondary clusters) and GINI_CLUST = T (a GINI-coefficient optimized set of hierarchical non-overlap secondary clusters).
Taken together as they are, the two sets of secondary clusters overlap, causing ambiguity in terms of which cluster-based relative risk score should be used at each location.
The source of confusion is in the SaTSCan software design to provide two distinct sets of overlapping results in the same table output.

**Unplanned Deviation for Reanalysis:**
If we load the correct SaTSCan results and filter the results to focus on the standard hierarchical set of clusters, is there consistency between SaTScan and SpatialEpi?

##STOPPED HERE, CODE SHOUDL BE FIXED BUT ACS_COVID NEEDS TO BE REBUILT

```{r spatial-cluster-compare}
## LOAD IN CORRECT SATSCAN RESULTS
# load SaTScan reproduced data
satscan_rpr_gis <- read_sf(here("data", "derived", "public", "satscan", "sat_scan_rpr.gis.shp"))
satscan_rpr_t <- satscan_rpr_gis %>% 
  st_drop_geometry() %>% 
  filter(GINI_CLUST == 'F') %>% 
  select(LOC_ID, CLU_RR)

acs_covid <- acs_covid[, 1:which(colnames(acs_covid) == "clusID")] %>% 
  left_join(satscan_rpr_t, by = join_by(fips == LOC_ID))

acs_covid <- acs_covid %>% 
  mutate(xcluster = case_when(
    !is.na(CLU_RR) & is.na(isCluster) ~ "SaTScan only",
    !is.na(CLU_RR) & !is.na(isCluster) ~ "Both SaTScan and SpatialEpi",
    is.na(CLU_RR) & !is.na(isCluster) ~ "SpatialEpi only",
    .default = NA
  ))

tmap_mode("view")
tm_basemap("OpenStreetMap.HOT") +
  tm_shape(acs_covid) +
  tm_fill(alpha = 0.7, col = "xcluster", palette = "RdYlGn", popup.vars = c("fips", "clusterID"), colorNA = NULL) +
  tm_layout(title = "Compare SaTScan to SpatialEpi")
```

The map above confirms that the source of differences in GEE clusters may be differences in Kulldorff spatial scan statistic calculations between SaTScan and SpatialEpi is both differences in user decisions and options and logical implementation of the selection of secondary clusters.

**Planned Deviation:**
Visualize the spatial distribution of COVID-19 risk classes used in the original study.

```{r original-risk-map, warning = FALSE, message = FALSE}
tmap_mode(mode = "plot")
tm4 <- tm_shape(acs_covid) +
  tm_polygons("ss_cluster_class",
    title = "COVID-19 Risk Class",
    breaks = c(0, 1, 2, 3, 4, 5, 8),
    border.alpha = .2,
    lwd = 0.2,
    palette = "YlOrBr",
    labels = c("1 - lowest risk", "2", "3", "4", "5", "6 - highest risk")
  ) +
  tm_shape(satscan_rpr_col) +
  tm_borders("red", lwd = .5) +
  tm_shape(state) +
  tm_borders("grey", lwd = .8) +
  tmap_options(check.and.fix = TRUE) +
  tm_layout(
    legend.position = c("left", "bottom"),
    legend.title.size = 0.8,
    legend.text.size = 0.5
  )

tm4

tmap_save(tm4, here("results", "figures", "rr_original.png"))
```

There are two issues with this conceptualization of COVID-19 risk.
First, only the 96 counties at the center of a cluster are considered in the risk classification.
Second, two sets of secondary clusters are included in the SaTScan output: hierarchical clusters and clusters optimized by GINI coefficient.
The two sets result in geographically overlapping clusters.

**Unplanned deviation for reanalysis**:
It would be more intuitive to include risk levels for all counties within a cluster (i.e. all counties within any of the circles above), rather than only the county at the center of a cluster.
It would also be more intuitive to choose one set of secondary clusters based on a single method, where the GINI coefficient method is designed to optimize difference between counties within clusters and couties outside.
Therefore, we will also calculate the final models using the `clusID` GEE clusters based on our SpatialEpi Kulldorff cluster relative risk.
Before doing so, let us investigate whether the SaTScan and SpatialEpi results align?

```{r compare-spatialepi-satscan}
satscan_gis <- read_sf(here("data", "derived", "public", "satscan", "sat_scan_rpr.gis.shp")) %>% 
  filter(GINI_CLUST == "F") %>% 
  st_drop_geometry() %>% 
  select(fips = LOC_ID, CLU_RR) 

ss_se <- acs_covid %>% 
  select(fips, rr_cluster, se_class = cluster_class) %>% 
  full_join(satscan_gis, by = "fips") %>% 
  mutate(
    se_cluster = ifelse(is.na(rr_cluster), "no", "yes"),
    ss_cluster = ifelse(is.na(CLU_RR), "no", "yes"),
    ss_class = ifelse(is.na(CLU_RR), 1, cut(CLU_RR, breaks, labels = FALSE))
  )

cat("COVID-19 Cluster Detection by County\n\n")
table(ss_se$se_cluster, ss_se$ss_cluster, dnn=c("SpatialEpi", "SaTScan"))

cat("\n\n\nCOVID-19 Risk Class by County\n\n")

table(ss_se$se_class, ss_se$ss_class, dnn=c("SpatialEpi", "SaTScan"))

# rm(satscan_gis, ss_se)
```

**Can we explain the differences here?** 
SaTScan first finds the highest likelihood cluster for each location.
Then, these are sorted from highest likelihood to lowest likelihood.
Clusters are added sequentially if they do not overlap any previously added clusters and if their *p* < 1.0.
(pg 68)
Clusters must contain < 0.5 population

SpatialEpi orders clusters by log-likelihood (line 186).
The algorithm excludes clusters with any geographic overlap with existing clusters (line 199).
The algorithm stops on the first cluster encountered with *p* > *alpha.level*, with default level of `0.05`
Clusters must contain < 0.5 population.

The main differences:

- selection of one cluster per location by SaTScan
- different threshold for maximum *p* value
- SaTScan includes only high likelihood ratios / relative risk > 1
- different methods and precision for calculating distance



https://github.com/rudeboybert/SpatialEpi/blob/master/R/kulldorff.R

```{r reanalyze-gee-clusters}




acs_covid <- acs_covid[, 1:which(colnames(acs_covid) == "clusID")] %>%
  left_join(satscan_gis[, c("LOC_ID", "CLU_RR", "LOC_RR")], by = join_by(fips == LOC_ID)) %>%
  left_join(satscan_col_t[, c("LOC_ID", "REL_RISK")], by = join_by(fips == LOC_ID))

breaks <- c(-Inf, 1, 2, 3, 4, 5, Inf)

acs_covid <- acs_covid %>%
  mutate(
    ss_loc_class = ifelse(is.na(LOC_RR), 1, cut(LOC_RR, breaks, labels = FALSE)),
    ss_cluster_class = ifelse(is.na(CLU_RR), 1, cut(CLU_RR, breaks, labels = FALSE)),
    ss_center_class = ifelse(is.na(REL_RISK), 1, cut(REL_RISK, breaks, labels = FALSE)),
    ss_locID = as.integer(statefp) * 10 + ss_loc_class,
    ss_clusID = as.integer(statefp) * 10 + ss_cluster_class,
    ss_centerID = as.integer(statefp) * 10 + ss_center_class
  )

rm(breaks)

cluster_summary <- acs_covid %>%
  filter(cases > 0) %>%
  st_drop_geometry() %>%
  count(ss_locID)
cat(
  length(cluster_summary$n),
  "unique clusters based on SaTScan local relative risk\n"
)
summary(cluster_summary$n)
cat("\r\n")

cluster_summary <- acs_covid %>%
  filter(cases > 0) %>%
  st_drop_geometry() %>%
  count(ss_clusID)
cat(
  length(cluster_summary$n),
  "unique clusters based on SaTScan cluster relative risk\n"
)
summary(cluster_summary$n)
cat("\r\n")

cluster_summary <- acs_covid %>%
  filter(cases > 0) %>%
  st_drop_geometry() %>%
  count(ss_centerID)
cat(
  length(cluster_summary$n),
  "unique clusters based on SaTScan cluster center relative risk\n"
)
summary(cluster_summary$n)
```



```{r satscan-gis}
satscan_gis <- read_sf(here("data", "derived", "public", "satscan", "sat_scan_rpr.gis.shp")) %>% st_drop_geometry()

```


### Map Relative Risk Scores

**Unplanned deviation**: Considering the inconsistent clustering results, we attempted to reproduce the original results using the original free (but not open source) SatSCan software.
We viewed the SatSCAN outputs in QGIS Desktop and discovered that the spatial ouptut includes two shapefiles: - gis point shapefile contains one point for each county in a cluster - col polygon shapefile containing a circle for each cluster, where each polygon is a circle defined by the cluster center and radius.

Note that relative risk is \> 1 only if the county was in a cluster





```{r map cluster based relative risk scores}
tm5 <- tm_shape(covid) +
  tm_polygons("cluster_class",
    title = "Relative Risk by Cluster",
    border.alpha = .2,
    lwd = 0.2,
    palette = "YlOrBr",
    style = "cat"
  ) +
  tm_shape(state) +
  tm_borders("grey", lwd = .5) +
  tmap_options(check.and.fix = TRUE) +
  tm_layout(
    legend.position = c("left", "bottom"),
    legend.title.size = 0.8,
    legend.text.size = 0.5
  )


tm5

tmap_save(tm5, here("results", "figures", "rr_reproduction_cluster.png"))
```

```{r map local relative risk score}
# Map Local Relative Risk scores
tm3 <- tm_shape(covid) +
  tm_polygons("loc_class",
    title = "Local Relative Risk",
    border.alpha = .2,
    lwd = 0.2,
    palette = "YlOrBr",
    style = "cat"
  ) +
  tm_shape(state) +
  tm_borders("grey", lwd = .5) +
  tmap_options(check.and.fix = TRUE) +
  tm_layout(
    legend.position = c("left", "bottom"),
    legend.title.size = 0.8,
    legend.text.size = 0.5
  )

tm3
tmap_save(tm3, here("results", "figures", "rr_reproduction_loc.png"))
```

## Preprocess data for GEE modelling

This accomplishes the step 9 and 10 of the workflow diagram

```{r preprocess data for GEE model }
covid_clusters <- covid %>%
  select(fips, clusterID, rr_cluster, cluster_class) %>% # change to loc_class if calculate local rr
  st_drop_geometry()

# Filter out non-positive COVID rates and missing data
# Create unique State - Relative Risk IDs by combining state code and rr_class
# Sort by the cluster id's (a requirement of the gee function)
gee_data <- left_join(acs_covid, covid_clusters, by = "fips") %>%
  filter(covid_rate > 0) %>%
  mutate(id = as.integer(statefp) * 10 + cluster_class) %>%
  arrange(id)


gee_data <- gee_data %>%
  mutate(
    z_bpov_pct = scale(bpov_pct),
    z_apov_pct = scale(apov_pct),
    z_white_pct = scale(white_pct),
    z_black_pct = scale(black_pct),
    z_native_pct = scale(native_pct),
    z_asian_pct = scale(asian_pct),
    z_other_pct = scale(other_pct),
    z_non_hisp_white_pct = scale(non_hisp_white_pct),
    z_hisp_pct = scale(hisp_pct),
    z_non_hisp_non_white_pct = scale(non_hisp_non_white_pct),
    z_pct_5_17 = scale(pct_5_17),
    z_pct_18_34 = scale(pct_18_34),
    z_pct_35_64 = scale(pct_35_64),
    z_pct_65_74 = scale(pct_65_74),
    z_pct_75 = scale(pct_75),
    z_male_pct = scale(male_pct),
    z_female_pct = scale(female_pct)
  )


rm(covid_clusters)
```

Optionally, you may save the preprocessed to `data/raw/public/gee_data.gpkg`

```{r save preprocessed COVID cluster data, eval = FALSE}
write_sf(gee_data, here("data", "derived", "public", "gee_data.gpkg"))
```

Optionally, you may load the preprocessed data from `data/raw/public/gee_data.gpkg`

```{r load preprocessed COVID cluster data, eval = FALSE}
gee_data <- read_sf(here("data", "derived", "public", "gee_data.gpkg"))
```

## GEE Models

This accomplishes the step 11 of the workflow diagram

Generalized Estimating Equation parameters:

"The **'exchangeable' correlation matrix** was selected for the results reported here, since this specification yielded the best statistical fit based on the QIC (quasi- likelihood under the independence) model criterion." (Chakraborty 2021, Methods paragraph 5)

"The **gamma distribution** with **logarithmic link function** was chosen for all GEEs since this model specification provided the lowest QIC value." (Chakraborty 2021, Methods paragraph 5)

Useful Reference: <https://data.library.virginia.edu/getting-started-with-generalized-estimating-equations/>

```{r glm model}
race_glm <- glm(
  covid_rate ~ z_white_pct + z_black_pct + z_native_pct + z_asian_pct + z_other_pct,
  data = gee_data,
  family = Gamma(link = "log")
)

ethnicity_glm <- glm(
  covid_rate ~ z_non_hisp_white_pct + z_hisp_pct + z_non_hisp_non_white_pct,
  data = gee_data,
  family = Gamma(link = "log")
)

pov_glm <- glm(
  covid_rate ~ z_bpov_pct + z_apov_pct,
  data = gee_data,
  family = Gamma(link = "log")
)

age_glm <- glm(
  covid_rate ~ z_pct_5_17 + z_pct_18_34 + z_pct_35_64 + z_pct_65_74 + z_pct_75,
  data = gee_data,
  family = Gamma(link = "log")
)

sex_glm <- glm(
  covid_rate ~ z_male_pct + z_female_pct,
  data = gee_data,
  family = Gamma(link = "log")
)


glm_results <- rbind(
  coef(summary(race_glm)),
  coef(summary(ethnicity_glm)),
  coef(summary(pov_glm)),
  coef(summary(age_glm)),
  coef(summary(sex_glm))
) %>%
  round(3)


coefrows <- rownames(glm_results)
coefrows[1] <- "Race Intercept"
coefrows[7] <- "Ethnicity Intercept"
coefrows[11] <- "Poverty Status Intercept"
coefrows[14] <- "Age Intercept"
coefrows[20] <- "Biological Sex Intercept"
rownames(glm_results) <- coefrows
glm_results
```

```{r gee models}
# it would be smarter to iterate over a list of models and their parameters
# currently stuck on how to add GLM model results to a cell of a dataframe
# not the only one:
# https://www.reddit.com/r/rstats/comments/p50mce/coding_a_loop_for_many_linear_regressions/

race_gee <- geeglm(
  covid_rate ~ z_white_pct + z_black_pct + z_native_pct + z_asian_pct + z_other_pct,
  data = gee_data, # data frame
  id = id, # cluster IDs
  family = Gamma(link = "log"),
  corstr = "exchangeable"
)

# Wald and P calculated in summary only;
# coef() extracts coefficients table from the summary, same as $coefficients

ethnicity_gee <- geeglm(
  covid_rate ~ z_non_hisp_white_pct + z_hisp_pct + z_non_hisp_non_white_pct,
  data = gee_data,
  id = id,
  family = Gamma(link = "log"),
  corstr = "exchangeable"
)

pov_gee <- geeglm(
  covid_rate ~ z_bpov_pct + z_apov_pct,
  data = gee_data,
  id = id,
  family = Gamma(link = "log"),
  corstr = "exchangeable",
)

age_gee <- geeglm(
  covid_rate ~ z_pct_5_17 + z_pct_18_34 + z_pct_35_64 + z_pct_65_74 + z_pct_75,
  data = gee_data,
  id = id,
  family = Gamma(link = "log"),
  corstr = "exchangeable"
)

sex_gee <- geeglm(
  covid_rate ~ z_male_pct + z_female_pct,
  data = gee_data,
  id = id,
  family = Gamma(link = "log"),
  corstr = "exchangeable"
)

# summarize model coefficients
coefficient_results <- rbind(
  coef(summary(race_gee)),
  coef(summary(ethnicity_gee)),
  coef(summary(pov_gee)),
  coef(summary(age_gee)),
  coef(summary(sex_gee))
) %>%
  round(3)

# disambiguate intercepts
coefrows <- rownames(coefficient_results)
coefrows[1] <- "Race Intercept"
coefrows[7] <- "Ethnicity Intercept"
coefrows[11] <- "Poverty Status Intercept"
coefrows[14] <- "Age Intercept"
coefrows[20] <- "Biological Sex Intercept"
rownames(coefficient_results) <- coefrows
coefficient_results

# summarize model QICs
QIC_results <- data.frame(
  race = QIC(race_gee),
  ethnicity = QIC(ethnicity_gee),
  poverty_status = QIC(pov_gee),
  age = QIC(age_gee),
  biological_sex = QIC(sex_gee)
) %>%
  round(3) %>%
  t() %>%
  as.data.frame() %>%
  select(QIC)
QIC_results
```

```{r preprocess original gee data}
original_processed <- original_gee %>%
  filter(Incidence > 0) %>%
  mutate(id = as.integer(COUNTY_FIPS) * 10 + RISK_BIN) %>%
  arrange(id)
```

```{r gee model with author provided data}
race_gee_original <- geeglm(
  Incidence ~ ZPD_White + ZPD_Black + ZPD_Asian + ZPD_Native + ZPD_OthRac,
  data = original_processed, # data frame
  id = id, # cluster IDs
  family = Gamma(link = "log"),
  corstr = "exchangeable"
)

ethnicity_gee_original <- geeglm(
  Incidence ~ ZPD_NHwhite + ZPD_Hispani + ZPD_NHoth,
  data = original_processed, # data frame
  id = id, # cluster IDs
  family = Gamma(link = "log"),
  corstr = "exchangeable"
)

pov_gee_original <- geeglm(
  Incidence ~ ZPDisBpov + ZPDisApov,
  data = original_processed, # data frame
  id = id, # cluster IDs
  family = Gamma(link = "log"),
  corstr = "exchangeable"
)

age_gee_original <- geeglm(
  Incidence ~ ZPD_age5to17 + ZPDage18to34 + ZPDage35to64 + ZPDage65to74 + ZPDage75,
  data = original_processed,
  id = id,
  family = Gamma(link = "log"),
  corstr = "exchangeable"
)

sex_gee_original <- geeglm(
  Incidence ~ ZPD_Male + ZPD_Female,
  data = original_processed, # data frame
  id = id, # cluster IDs
  family = Gamma(link = "log"),
  corstr = "exchangeable"
)

coefficient_results_original <- rbind(
  coef(summary(race_gee_original)),
  coef(summary(ethnicity_gee_original)),
  coef(summary(pov_gee_original)),
  coef(summary(age_gee_original)),
  coef(summary(sex_gee_original))
) %>%
  round(3)

coefrows <- rownames(coefficient_results_original)
coefrows[1] <- "Race Intercept"
coefrows[7] <- "Ethnicity Intercept"
coefrows[11] <- "Poverty Status Intercept"
coefrows[14] <- "Age Intercept"
coefrows[20] <- "Biological Sex Intercept"
rownames(coefficient_results_original) <- coefrows
coefficient_results_original


QIC_results_original <- data.frame(
  race = QIC(race_gee_original),
  ethnicity = QIC(ethnicity_gee_original),
  poverty_status = QIC(pov_gee_original),
  age = QIC(age_gee_original),
  biological_sex = QIC(sex_gee_original)
) %>%
  round(3) %>%
  t() %>%
  as.data.frame() %>%
  select(QIC)
QIC_results_original
```
