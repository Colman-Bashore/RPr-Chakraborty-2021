---
output: html_document
---
# Pre-Registration of Rpr-Reproduction of Social Inequities in the distribution of COVID-19: An intra-categorical analysis of people with disabilities in the U.S.

Joseph Holler, Department of Geography, Middlebury College, Middlebury VT 05753
Peter Kedron, School of Geographical Sciences and Urban Planning, Arizona State University, Tempe AZ 85281 
Drew An-Pham, Department of Geography, Middlebury College, Middlebury VT 05753 Derrick Burt, Department of Geography, Middlebury College, Middlebury VT 05753

Version 1.0 | Created Jul 7, 2021 | Last Updated Jul 22, 2021

# Abstract

Chakraborty (2021) investigates the relationships between COVID-19 rates and demographic characteristics of people with disabilities by county in the lower 48 states. The study aims to examine public concern that persons with disabilities (PwDs) face disproportionate challenges due to COVID-19. To investigate this, Chakraborty examines the statistical relationship between confirmed county-level COVID-19 case rates and county-level socio-demographic and disability variables. Specifically, Chakraborty tests county-level bivariate correlations between COVID-19 incidence against the percentage of disability and socio-demographic category, with a separate hypothesis and model for each subcategory within disability, race, ethnicity, age, and biological sex. To control for differences between states and geographic clusters of COVID-19 outbreaks, Chakraborty uses five generalized estimating equation (GEE) models to predict the relationship and significance between COVID-19 incidence and disability subgroups within each socio-demographic category while considering inter-county spatial clusters. Chakraborty (2021) finds significant positive relationships between COVID-19 rates and socially vulnerable demographic categories of race, ethnicity, poverty, age, and biological sex.

This reproduction study is motivated by expanding the potential impact of Chakraborty's study for policy, research, and teaching purposes. Measuring the relationship between COVID-19 incidence and socio-demographic and disability characteristics can provide important information for public health policy-making and resource allocation. A fully reproducible study will increase the accessibility, transparency, and potential impact of Chakraborty's (2021) study by publishing a compendium complete with metadata, data, and code. This will allow other researchers to review, extend, and modify the study and will allow students of geography and spatial epidemiology to learn from the study design and methods.

In this reproduction, we will attempt to identically reproduce all of the results from the original study. This will include the map of county level distribution of COVID-19 incidence rates (Fig. 1), the summary statistics for disability and sociodemographic variables and bivariate correlations with county-level COVID-19 incidence rate (Table 1), and the GEE models for predicting COVID-19 county-level incidence rate (Table 2). A successful reproduction should be able to generate identical results as published by Chakraborty (2021).

The replication study data and code will be made available in a GitHub repository to the greatest extent that licensing and file sizes permit. The repository will be made public at [github.com/HEGSRR/RPr-Chakraborty2021](). To the greatest extent possible, the reproduction will be implemented with (3.7.6) Jupyter Notebooks for implementation on the CyberGISX platform with Python (3.7.6) Jupyter Notebooks.

Chakraborty, J. 2021. Social inequities in the distribution of COVID-19: An intra-categorical analysis of people with disabilities in the U.S. Disability and Health Journal 14:1-5. DOI:[10.1016/j.dhjo.2020.101007]()

### Keywords
COVID-19; Disability; Intersectionality; Race/ethnicity; Poverty; Reproducibility

## Study Design
The reproduction study will try to implement the original study as closely as possible to reproduce the map of county level distribution of COVID-19 incidence rate, the summary statistics and bivariate correlation for disability characteristics and COVID-19 incidence, and the generalized estimating equations.
Our two confirmatory hypotheses are that we will be able to exactly reproduce Chakraborty's results as presented in table 1 and table 2 of Chakraborty (2021). Stated as null hypotheses:

> H1: There is a less than perfect match between Chakraborty's bivariate correlation coefficient for each disability/sociodemographic variable and COVID-19 incidence rate and our bivariate correlation coefficient for each disability/sociodemographic variable and COVID-19 incidence rate.

> H2: There is a less than perfect match between Chakraborty's beta coefficient for the GEE of each disability/sociodemographic variable an statistics and our beta coefficient for the GEE of each disability/sociodemographic variable.

There are multiple models being tested within each of the two hypotheses. That is, H1 and H2 both encompass five models, including one for each dimension of socio-demographics: race, ethnicity, poverty status, age, and biological sex.

### Original study design

The original study is **observational**, with the **exploratory** objective of determining "whether COVID-19 incidence is significantly greater in counties containing higher percentages of socio-demographically disadvantaged [people with disabilities], based on their race, ethnicity, poverty status, age, and biological sex" (Chakraborty 2021).
This exploratory objective is broken down into five implicit hypotheses that each of the demographic characteristics of people with disabilities is associated with higher COVID-19 incidence rates.

The **spatial extent** of the study are the 49 contiguous states in the U.S.
The **spatial scale** of the analysis is at the county level.
Both COVID-19 incidence rates and demographic variables are all measured at the county level.
The **temporal extent** of the COVID-19 data ranges from 1/22/2020 (when John Hopkins began collecting the data) to 8/1/2020 (when the data was retrieved for the original study).
The data on disability and sociodemographic characteristics come from the U.S. Census American Community Survey (ACS) five-year estimates for 2018 (2014-2018).

There is no **randomization** in the original study.

The study was originally conducted using SaTScan software (unspecified version) to implement the spatial scan statistic.
Other software are not specified in the publication; however data files and communication with the author show that spatial analysis and mapping was conducted in ArcGIS and statistics were calculated in SPSS.

```{r Load Data File, include = F}
packages = c("tidycensus", "tidyverse", "downloader", "haven", "stars", "dplyr", "sf", "rdhs", "classInt", "readr", "ggplot2", "here", "s2", "pastecs", "cartography", "vtable", "SpatialEpi", "svDialogs")
setdiff(packages, rownames(installed.packages()))
install.packages(setdiff(packages, rownames(installed.packages())), quietly=TRUE)

library(tidycensus)
library(tidyverse)
library(downloader)
library(haven)
library(sf)
library(stars)
library(dplyr) # may not need this if you have tidyverse
library(here)
library(classInt)
library(rdhs)
library(readr)
library(ggplot2)
library(s2)
library(pastecs)
library(cartography)
library(vtable)
library(SpatialEpi)
library(svDialogs)
library(gee)

```

```{r formatting package versions}
# list of required packages
packages = c("here")

# load and install required packages
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

# save the R processing environment 
writeLines(capture.output(sessionInfo()),here("procedure","environment","r_environment.txt"))

# read in R processing environment
# the data frame package_version provides info on the libraries used for this analysis when previewed in the console
package_version <- read.delim(here("procedure","environment","r_environment.txt"))
```

```{r create values to access private and public raw data more efficiently}
private_r = here("data","raw","private")
public_r = here("data","raw","public")
```

```{r Load Data Files, message = F}
# ACS_old <- read_csv(here(public_r, "disability", "ACSST5Y2018.S1810_data_with_overlays_2021-07-22T152024.csv"))
# GEE <- read_csv(here(public_r, "gee", "Aug1GEEdata.csv"))

census_api_key(dlgInput("Enter a Census API Key", 
                        Sys.getenv("CENSUS_API_KEY"))$res,
               overwrite = TRUE)

#insert if not statement, if disability raw exists
# read both data sets in, join, then drop alaska + hawaii

# IF file doesn't exist:

acs <- get_acs(geography = "county",
               table = "S1810",
               year = 2018,
               output = "wide",
               cache_table = TRUE,
               geometry = TRUE,
               keep_geo_vars = TRUE) 

acs_pov <- get_acs(geography = "county",
                   table = "C18130",
                   year = 2018,
                   output = "wide",
                   cache_table = TRUE
)

# Filter out Alaska, Hawaii & Puerto Rico
acs <- filter(acs, !STATEFP %in% c("02", "15", "72"))

# Join poverty data to acs data
acs <- left_join(acs, acs_pov, by = "GEOID")
rm(acs_pov)

# Save downloaded acs data to acs.gpkg
st_write(acs, here("data", "raw", "public", "acs.gpkg"), append=FALSE)
```

Optionally, you may start here by loading census data from the repository
```{r Load downloaded data, message = F}
acs <- st_read(here("data", "raw", "public", "acs.gpkg"))
```

```{r Preprocess ACS data, message = F}
# calculate percentages
acs <- mutate(acs,
              dis_pct = S1810_C02_001E / S1810_C01_001E * 100,
              white_pct = S1810_C02_004E / S1810_C01_001E * 100,
              black_pct = S1810_C02_005E / S1810_C01_001E * 100,
              native_pct = S1810_C02_006E / S1810_C01_001E * 100,
              asian_pct = S1810_C02_007E / S1810_C01_001E * 100,
              other_pct = (S1810_C02_008E + S1810_C02_009E + S1810_C02_010E)/S1810_C01_001E *100,
              non_hisp_pct = S1810_C02_011E / S1810_C01_001E * 100,
              non_hisp_non_white_pct = (S1810_C02_001E - S1810_C02_012E - S1810_C02_011E) / S1810_C01_001E * 100,
              hisp_pct = S1810_C02_012E / S1810_C01_001E * 100,
              pct_5_17 = S1810_C02_014E / S1810_C01_001E * 100,
              pct_18_34 = S1810_C02_015E / S1810_C01_001E * 100,
              pct_35_64 = S1810_C02_016E / S1810_C01_001E * 100,
              pct_65_74 = S1810_C02_017E / S1810_C01_001E * 100,
              pct_75 = S1810_C02_018E / S1810_C01_001E * 100,
              male_pct = S1810_C02_002E / S1810_C01_001E * 100,
              female_pct = S1810_C02_003E / S1810_C01_001E * 100,
              bpov_pct = (C18130_004E + C18130_011E + C18130_018E) / C18130_001E * 100, 
              apov_pct = (C18130_005E + C18130_012E + C18130_019E) / C18130_001E * 100
) 

# remove raw acs totals
acs <- acs %>% 
  select(
    -contains("S181"),
    -contains("C181"),
    -COUNTYNS,
    -AFFGEOID,
    -LSAD,
    -ALAND,
    -AWATER,
    -NAME.y) %>% 
  rename(county = NAME.x) %>% 
  rename(county_st = NAME) %>% 
  rename_with(tolower)

# one feature (GEOID 35039) is missing poverty data
acs[is.na(acs$bpov_pct), ]

```

```{r load covid data}
covid <- read_sf(here("data", "raw", "public","gee","Aug1data","Aug1data.shp"))
covid <- select(covid,
            FIPS, ST_Abbr,
            pop = POP_ESTIMA,
            cases = Confirmed,
            x=X, y=Y)
covid$covid_rate <- covid$cases / covid$pop * 100000
covid_table <- st_drop_geometry(covid)

# Join poverty data to acs data
covid_rate_table <- select(covid_table, FIPS, covid_rate)
acs <- left_join(acs, covid_rate_table, by=c("geoid"="FIPS"))

```

```{r pearsons correlation}
# helpful resource: https://rstudio-pubs-static.s3.amazonaws.com/240657_5157ff98e8204c358b2118fa69162e18.html

pearsons_r <- acs %>%
  select(where(is.numeric)) %>% 
  st_drop_geometry() %>% 
  cor(method="pearson", use="pairwise.complete.obs") %>% 
  round(3) 
pearsons_r <- pearsons_r[ , "covid_rate"]
df = sum(!is.na(acs$dis_pct)) - 2

# this estimation of t gives similar, but not identical, result to 
# corr.test
pearsons_t = abs(pearsons_r) / sqrt((1 - pearsons_r^2)/(df))

# assuming two-tailed test or checked assumptions
pearsons_p <- pt(pearsons_t, df, lower.tail = FALSE) %>% 
  round(4)

# might want to add these results as three columns of a data frame
# and then remove the covid_rate row
```

```{r SpatialEpi Kulldorff spatial scan}
covid_geo <- covid_table %>% 
  select(x, y) %>%
  latlong2grid()

# calculate expected cases with one strata
expected.cases <- expected(covid_table$pop, covid_table$cases , 1)

# Kulldorff spatial scan statistic
covid_kulldorff <- kulldorff(geo=covid_geo,
                             cases=covid_table$cases,
                             population=covid_table$pop,
                             expected.cases=expected.cases,
                             pop.upper.bound=0.5,
                             n.simulations=999,
                             alpha.level=0.05,
                             plot=TRUE
)

rm(covid_table, covid_geo, expected.cases)
```

```{r summarize Kulldorff results}
# Get counties in most significant cluster
# Note that the ID numbers are row numbers
clusters <- covid_kulldorff$most.likely.cluster$location.IDs.included

# Get list of secondary clusters
secondary <- covid_kulldorff$secondary.clusters

# Get counties from each secondary cluster
for (i in secondary) {
  clusters <- c(clusters, i$location.IDs.included)
}

# Create blank column "cluster" with 0's
covid$cluster <- 0

# Change cluster to 1 for any county identified in any cluster
covid[clusters, ]$cluster <- 1

cases_sum <- sum(covid$cases)
pop_sum <- sum(covid$pop)

# Calculate Local Relative Risk
covid <- mutate(covid, 
  loc_rr = (cases / pop) / ((cases_sum - cases) / (pop_sum - pop))
)

# Classify relative risk from 1 to 6
covid$rr_class <- cut(covid$loc_rr, c(-Inf,1,2,3,4,5,Inf), labels=FALSE )

# Set relative risk to 1 if county was not in a cluster
covid[covid$cluster==0, ]$rr_class <- 1

# Map Relative Risk scores
# Note that relative risk is > 1 only if the county was in a cluster
library(tmap)
tm_shape(covid) +
  tm_polygons("rr_class", 
    title="Local Relative Risk",
    border.alpha = .2,
    lwd = 0.2
  )

paste(sum(covid$cluster==0 & covid$loc_rr >= 1),
      "counties lie outside of a cluster and have local relative risk > 1")

rm(cases_sum, pop_sum)


```

```{r save derived COVID cluster data}
st_write(covid, here("data","derived","public","covid_clusters.gpkg"), append = FALSE)

covid <- st_read(here("data","derived","public","covid_clusters.gpkg"))
```


```{r preprocess data for GEE model }
# Create unique State - Relative Risk IDs
covid$strr <- paste(covid$ST_Abbr, covid$rr_class)

covid_clusters <- covid %>% 
  select(FIPS, cluster, loc_rr, rr_class, strr) %>% 
  st_drop_geometry

acs <- left_join(acs, covid_clusters, by = c("geoid"="FIPS"))

# Sort by the STRR cluster id, a requirement of the gee function
acs <- arrange(acs, strr)
```

```{r map covid rates}
acs$bins <- cut(acs$rr_class, 
                breaks=c(-Inf, 0,  1, 2, 3, 4, 5, Inf),
                labels=c("NA", "<1","1.00-1.99","2.00-2.99","3.00-3.99","4.00-4.99",">5"))

covid_rate_map <- ggplot() + 
  geom_sf(data = acs,
          aes(fill = bins), size = .1) + 
  scale_fill_brewer(palette = "YlOrBr")
covid_rate_map
```

```{r z-score normalization}

# formula applies to every cell of a matrix... 

# try extracting just the pct and rate columns from acs and save as new data frame, gee_vars
gee_data <- acs %>%
  select(contains("pct"), contains("rate"), "geoid", "strr") %>%
  mutate(dis_z = (dis_pct - mean(dis_pct) / sd(dis_pct)),
         white_z = (white_pct - mean(white_pct) / sd(white_pct)),
         black_z = (black_pct - mean(black_pct) / sd(black_pct)),
         native_z = (native_pct - mean(native_pct) / sd(native_pct)),
         asian_z = (asian_pct - mean(asian_pct) / sd(asian_pct)),
         other_z = (other_pct - mean(other_pct) / sd(other_pct)),
         non_hisp_z = (non_hisp_pct - mean(non_hisp_pct) / sd(non_hisp_pct)),
         non_hisp_non_white_z = (non_hisp_non_white_pct - mean(non_hisp_non_white_pct) / sd(non_hisp_non_white_pct)),
         hisp_z = (hisp_pct - mean(hisp_pct) / sd(hisp_pct)),
         bpov_z = (bpov_pct - mean(bpov_pct, na.rm = TRUE) / sd(bpov_pct, na.rm = TRUE)),
         apov_z = (apov_pct - mean(apov_pct, na.rm = TRUE) / sd(apov_pct, na.rm = TRUE)),
         z_5_17 = (pct_5_17 - mean(pct_5_17) / sd(pct_5_17)),
         z_18_34 = (pct_18_34 - mean(pct_18_34) / sd(pct_18_34)),
         z_35_64 = (pct_35_64 - mean(pct_35_64) / sd(pct_35_64)),
         z_65_74 = (pct_65_74 - mean(pct_65_74) / sd(pct_65_74)),
         z_75 = (pct_75 - mean(pct_75) / sd(pct_75)),
         male_z = (male_pct - mean(male_pct) / sd(male_pct)),
         female_z = (female_pct - mean(female_pct) / sd(female_pct)),
         covid_rate_z = (covid_rate - mean(covid_rate) / sd(covid_rate))
         ) %>%
  select(contains("z"), "geoid", "strr") %>%
  st_drop_geometry()

  
```

```{r z-score using iteration/for loops}
# iteratively replace all the values with z-scores: x - mean(x) / st(x)
# two ideas for iterating: try evaluating columns based on column index with a for loop,
# or try creating a list of the columns names, and iterating over the list

# gee_columns <- list(gee_data)

#for (i in gee_columns) {
#gee_data$i <- (gee_data$i - mean(gee_data$i) / sd(gee_data$i))}

#for i in 1:length(mycolumns ) {
#gee_data[ ,i] <- (gee_data[ ,i] - mean(gee_data[ ,i]) / sd(gee_data[ ,i])}
```

## GEE Model

From https://data.library.virginia.edu/getting-started-with-generalized-estimating-equations/

dep_gee <- gee(depression ~ diagnose + drug*time,
data = dat, 
id = CLUSTER, 
family = binomial,
corstr = "independence")
summary(dep_gee)

From Chakraborty:

"gamma distribution with logarithmic link function was chosen for all GEEs since"


```{r gee model}
# one feature (GEOID 35039) is missing poverty data

# test <- test[test$FIPS != 35039, ]

pov_gee <- gee(covid_rate ~ bpov_pct + apov_pct, # regression formula, dependent var first, then sequence of independent variables
               data = filter(acs, bpov_pct>0 & apov_pct>0 & covid_rate >0), # data frame
               id = strr, # cluster IDs
               family = Gamma(link = "log"), # "gamma distribution with logarithmic link function"
               corstr = "exchangeable" # use exchangeable correlation matrix
)
summary(dep_gee)

```



```{r attempting DCluster methods}
# Note that DCluster loads MASS which as a SELECT function conflicting with dplyr
# covid <- read_sf(here("data", "raw", "public","gee","Aug1data","Aug1data.shp"))
# covid_data <- covid %>% mutate(Observed = Confirmed, Expected = Confirmed * sum(Confirmed)/sum(POP_ESTIMA), Population=POP_ESTIMA, x=X, y=Y )
# 
# kn.pboot<-boot(covid_data, statistic=kullnagar.pboot, sim="parametric", 
# 	ran.gen=poisson.sim,  R=999, fractpop=.2)
# plot(kn.pboot)
# 
# mle<-calculate.mle(covid_data, model="poisson")
# thegrid=st_drop_geometry(covid_data[,c("x","y")])
# knresults<-opgam(data=covid_data, thegrid=thegrid, alpha=0.1,
#   iscluster=kn.iscluster, fractpop=.5, R=9, model="poisson", mle=mle)
```

# Select relevant columns
acs <- select(acs,
NAME = "NAME.x",
"STATEFP",
"COUNTYFP",
"GEOID",
"S1810_C01_001E",
"S1810_C02_001E",
"S1810_C02_004E",
"S1810_C02_005E",
"S1810_C02_006E",
"S1810_C02_007E",
"S1810_C02_008E",
"S1810_C02_009E",
"S1810_C02_010E",
"S1810_C02_011E",
"S1810_C02_012E",
"S1810_C02_014E",
"S1810_C02_015E",
"S1810_C02_016E",
"S1810_C02_017E",
"S1810_C02_018E",
"S1810_C02_002E",
"S1810_C02_003E",
"C18130_001E",
"C18130_004E",
"C18130_005E",
"C18130_011E",
"C18130_012E",
"C18130_018E",
"C18130_019E")
